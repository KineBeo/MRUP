\clearpage
\phantomsection

\setcounter{chapter}{4}
\chapter[{ĐÁNH GIÁ}]{Đánh giá}

Chương này đánh giá kỹ thuật phát triển và mức độ sẵn sàng triển khai của MRUP Oracle. Thay vì tập trung vào phát hiện lỗi—một yếu tố phụ thuộc vào độ trưởng thành của DBMS và phạm vi của oracle—chúng tôi đánh giá liệu MRUP có triển khai chính xác các nguyên tắc thiết kế của nó hay không. Cụ thể, chúng tôi đặt ra các câu hỏi: Liệu MRUP có tuân thủ hệ thống ràng buộc của nó? Các chiến lược đột biến có đạt được sự đa dạng mục tiêu không? Bộ so sánh có xác định và không tạo ra false positive không? Và thông lượng có đủ để kiểm thử liên tục? Những câu hỏi này xác định liệu MRUP có là một công cụ kiểm thử có kỷ luật, ổn định, sẵn sàng cho đánh giá quy mô lớn hay không.

\section{Mục tiêu và phương pháp đánh giá}

Mục tiêu của chương này là đánh giá chính oracle, chứ không phải DBMS. Thay vì đo lường khả năng phát hiện lỗi—điều phụ thuộc vào độ trưởng thành của DBMS và phạm vi của oracle—chúng tôi đánh giá liệu MRUP có triển khai đúng các nguyên tắc thiết kế của nó hay không.

\subsection{Câu hỏi nghiên cứu}

Chúng tôi đặt ra bốn câu hỏi nghiên cứu (Research Questions - RQs) để đánh giá chất lượng kỹ thuật của MRUP Oracle:

\textbf{RQ1: Tuân thủ ràng buộc.} MRUP Oracle có thực thi chính xác hệ thống ràng buộc (C0-C5) của nó trên các truy vấn được sinh ra đa dạng không?

Một oracle có kỷ luật không được vi phạm các đảm bảo ngữ nghĩa của chính nó. RQ này kiểm chứng rằng hệ thống ràng buộc là đúng đắn và được áp dụng nhất quán.

\textbf{RQ2: Độ phủ và sự đa dạng của đột biến.} Phân bố và sự đa dạng của các đột biến được áp dụng bởi MRUP Oracle như thế nào?

Một oracle hiệu quả phải khám phá các mẫu truy vấn đa dạng. RQ này định lượng liệu các chiến lược đột biến có đạt được mục tiêu thiết kế của chúng hay không.

\textbf{RQ3: Tính ổn định của bộ so sánh.} Bộ so sánh 3 tầng có tạo ra kết quả nhất quán, xác định qua các lần thực thi lặp lại không?

False positive làm giảm độ tin cậy của oracle. RQ này kiểm chứng rằng bộ so sánh là ổn định và nhận biết kiểu dữ liệu.

\textbf{RQ4: Thông lượng và hiệu suất của oracle.} Thông lượng sinh và thực thi test case của MRUP Oracle là bao nhiêu?

Một oracle thực tế phải đủ hiệu quả cho kiểm thử liên tục. RQ này thiết lập các đặc tính hiệu suất cơ bản.

\subsection{Phương pháp đánh giá}

Đánh giá của chúng tôi dựa trên phân tích log file từ việc thực thi MRUP Oracle. Mỗi test case được ghi nhận đầy đủ bao gồm: schema đã sinh, truy vấn đã tạo, các đột biến đã áp dụng, ràng buộc đã kiểm tra, kết quả thực thi, và quyết định so sánh. Tất cả các metric được trích xuất tự động từ log, đảm bảo tính tái tạo và loại bỏ chú thích thủ công.

\section{Thiết lập thực nghiệm}

\subsection{Môi trường kiểm thử}

Tất cả các thí nghiệm được thực hiện trong môi trường được kiểm soát để đảm bảo tính tái tạo. Cấu hình hệ thống bao gồm:

\textbf{Phần cứng:}
\begin{itemize}[label=\textbullet]
    \item CPU: Intel Core i7-10700K @ 3.8GHz (8 cores, 16 threads)
    \item RAM: 32GB DDR4
    \item Storage: 1TB NVMe SSD
\end{itemize}

\textbf{Phần mềm:}
\begin{itemize}[label=\textbullet]
    \item Hệ điều hành: Ubuntu 22.04 LTS
    \item Java Runtime: OpenJDK 17.0.9
    \item SQLite: Phiên bản 3.45.0 (stable, tháng 1/2024)
    \item SQLancer Framework: Phiên bản tích hợp MRUP Oracle
\end{itemize}

\subsection{Tập dữ liệu kiểm thử}

Đánh giá chính được thực hiện trên 13740  test case được sinh tự động bởi MRUP Oracle. Mỗi test case bao gồm:
\begin{itemize}[label=\textbullet]
    \item Một cặp bảng (t1, t2) với schema ngẫu nhiên (3-7 cột)
    \item Các giá trị partition rời rạc (dept ∈ {A, B, C} cho t1; dept ∈ {X, Y, Z} cho t2)
    \item 3-8 hàng dữ liệu mỗi bảng với edge case (NULL, MIN\_INT, MAX\_INT)
    \item Một truy vấn window function với PARTITION BY và ORDER BY
    \item Các đột biến được áp dụng (identity wrapper + CASE WHEN)
\end{itemize}

Đối với kiểm thử tính ổn định (RQ3), chúng tôi chạy lặp lại 100 test case, mỗi test case 10 lần, để đo lường tính xác định của bộ so sánh.

\subsection{Thu thập dữ liệu}

MRUP Oracle được cấu hình để ghi log chi tiết cho mỗi test case. Log file bao gồm:
\begin{itemize}[label=\textbullet]
    \item Cấu trúc schema và dữ liệu đã sinh
    \item Truy vấn window function gốc và sau đột biến
    \item Kết quả kiểm tra ràng buộc C0-C5 (boolean map)
    \item Loại đột biến đã áp dụng và tỷ lệ thành công
    \item Kết quả thực thi (cardinality, partition distribution)
    \item Quyết định của bộ so sánh (tầng nào được sử dụng)
    \item Thời gian thực thi cho mỗi giai đoạn (generation, execution, comparison)
\end{itemize}

Các metric được trích xuất tự động từ log file bằng script phân tích, loại bỏ chú thích thủ công và đảm bảo tính khách quan.

\section{Metrics đánh giá}

Phần này định nghĩa các metric được sử dụng để trả lời RQ1-RQ4. Tất cả các metric đều thỏa mãn các tiêu chí: trích xuất được từ code, độc lập với phát hiện lỗi, tập trung vào oracle, có khả năng diễn giải, tái tạo được, nhạy cảm với ràng buộc, tối thiểu, và sẵn sàng cho công bố khoa học.

\subsection{M1: Tỷ lệ thỏa mãn ràng buộc}

\textbf{Định nghĩa:} Phần trăm các truy vấn được sinh thỏa mãn tất cả ràng buộc C0-C5.

\textbf{Trích xuất:} Hàm \texttt{verifyConstraints()} ghi nhận boolean map cho mỗi test case. Metric được tính bằng cách đếm số test case có tất cả 6 ràng buộc đều true.

\textbf{Giá trị kỳ vọng:} 100\%. Bất kỳ vi phạm nào đều chỉ ra lỗi triển khai trong oracle.

\textbf{Ý nghĩa:} Metric này đo lường trực tiếp tính đúng đắn của oracle. Hệ thống ràng buộc là nền tảng của tính đúng đắn ngữ nghĩa của MRUP—nếu một ràng buộc bị vi phạm, quan hệ metamorphic không còn đúng và oracle sẽ tạo ra false positive.

\subsection{M2-M3: Tỷ lệ áp dụng và phân bố đột biến}

\textbf{M2—Tỷ lệ áp dụng đột biến theo loại:}
\begin{itemize}[label=\textbullet]
    \item Window spec mutations: Mục tiêu \textasciitilde90\% (thử 5 lần, skipped nếu vi phạm C4)
    \item Identity mutations: Mục tiêu \textasciitilde98\% (skipped cho ranking function)
    \item CASE WHEN mutations: Mục tiêu 100\% (luôn áp dụng)
\end{itemize}

\textbf{M3—Phân bố chiến lược CASE WHEN:}
\begin{itemize}[label=\textbullet]
    \item Strategy 1 (Constant): Mục tiêu 30\%
    \item Strategy 2 (Window in WHEN): Mục tiêu 25\%
    \item Strategy 3 (Different Functions): Mục tiêu 20\%
    \item Strategy 4 (Identical Branches): Mục tiêu 15\%
    \item Strategy 5 (NULL Handling): Mục tiêu 10\%
\end{itemize}

\textbf{Trích xuất:} Pipeline đột biến được ghi log cho mỗi test case, bao gồm loại đột biến đã áp dụng hoặc lý do skipped.

\textbf{Giá trị kỳ vọng:} Tỷ lệ quan sát phải nằm trong ±5\% so với mục tiêu. Độ lệch lớn hơn chỉ ra bias trong logic sinh ngẫu nhiên hoặc lỗi trong điều kiện applicability.

\textbf{Ý nghĩa:} Các metric này đo lường liệu các chiến lược đột biến có đạt được mục tiêu thiết kế của chúng hay không. Sự đa dạng cao trong đột biến tương quan với khám phá không gian trạng thái tốt hơn.

\subsection{M4: Đa dạng schema và truy vấn}

\textbf{Đa dạng schema:}
\begin{itemize}[label=\textbullet]
    \item Số cột: 3-7 (mục tiêu: trung bình 4.5-5.0)
    \item Phân bố kiểu: 40\% INTEGER, 30\% REAL, 30\% TEXT
    \item Tỷ lệ NULL: \textasciitilde30\% cho các cột bổ sung
    \item Tỷ lệ edge case: \textasciitilde15\% cho các cột số (MIN\_INT, MAX\_INT, 0)
\end{itemize}

\textbf{Đa dạng truy vấn:}
\begin{itemize}[label=\textbullet]
    \item Loại window function: 98\% aggregate, 2\% ranking
    \item Số cột ORDER BY: 1-3 (phân bố đều)
    \item Có frame: \textasciitilde50\% cho aggregate function
    \item Loại frame: phân bố ROWS vs RANGE
\end{itemize}

\textbf{Trích xuất:} Cấu trúc schema và truy vấn được ghi log cho mỗi test case.

\textbf{Giá trị kỳ vọng:} Phân bố quan sát phải khớp với phân bố được chỉ định trong code.

\textbf{Ý nghĩa:} Các metric này định lượng độ đa dạng của đầu vào. Đa dạng cao chỉ ra rằng oracle khám phá kỹ lưỡng không gian kiểm thử.

\subsection{M5: Tỷ lệ validation disjoint partition}

\textbf{Định nghĩa:} Phần trăm các cặp bảng có partition được xác nhận là rời rạc.

\textbf{Giá trị kỳ vọng:} 100\%. Bất kỳ vi phạm nào đều phá vỡ nền tảng của MRUP.

\textbf{Ý nghĩa:} Tính disjoint của partition là điều kiện tiên quyết cho quan hệ metamorphic.
Nếu partition không rời rạc, $H(t_1 \cup t_2) = H(t_1) \cup H(t_2)$ không đúng.


\subsection{M6: Sử dụng tầng của bộ so sánh}

\textbf{Định nghĩa:} Phần trăm test case đạt tới mỗi tầng của bộ so sánh.

\textbf{Phân tích:}
\begin{itemize}[label=\textbullet]
    \item Tầng 1 (Cardinality): 100\% (luôn thực thi)
    \item Tầng 2 (Normalization): \% vượt qua Tầng 1
    \item Tầng 3 (Per-partition): \% vượt qua Tầng 2
\end{itemize}

\textbf{Trích xuất:} Luồng so sánh được ghi log cho mỗi test case, ghi nhận tầng nào được thực thi và quyết định tại mỗi tầng.

\textbf{Giá trị kỳ vọng:} Giả sử SQLite chủ yếu đúng, \textasciitilde100\% test case nên vượt qua cả 3 tầng. Các test case không vượt qua chỉ ra bug tiềm năng hoặc edge case chưa xử lý.

\textbf{Ý nghĩa:} Metric này đo lường hiệu quả của kiến trúc 3 tầng. Phân bố tầng chỉ ra nơi xảy ra mismatch.

\subsection{M7: Thông lượng sinh test case}

\textbf{Định nghĩa:} Số test case được sinh và thực thi mỗi giây.

\textbf{Trích xuất:} Được đo bằng timestamp trong log file. Thông lượng = tổng số test case / tổng thời gian thực thi.

\textbf{Giá trị kỳ vọng:} 10-100 test case/giây (điển hình cho SQL testing tool).

\textbf{Phân tích chi tiết:} Thời gian cho mỗi giai đoạn:
\begin{itemize}[label=\textbullet]
    \item Sinh bảng: \textasciitilde3 ms
    \item Sinh truy vấn: \textasciitilde1 ms
    \item Áp dụng đột biến: \textasciitilde1 ms
    \item Thực thi truy vấn: \textasciitilde12 ms
    \item So sánh kết quả: \textasciitilde4 ms
\end{itemize}

\textbf{Ý nghĩa:} Metric này đánh giá tính thực tế của oracle. Thông lượng cao cho phép kiểm thử liên tục và khám phá quy mô lớn.

\subsection{M8: Phân bố độ phức tạp truy vấn}

\textbf{Định nghĩa:} Phân bố các đặc tính truy vấn được sinh.

\textbf{Các chiều:}
\begin{itemize}[label=\textbullet]
    \item Loại window function (aggregate vs ranking)
    \item Số cột ORDER BY (1, 2, hoặc 3)
    \item Có frame clause hay không
    \item Loại frame (ROWS vs RANGE)
    \item Hướng ORDER BY (ASC vs DESC)
    \item Xử lý NULLS (NULLS FIRST vs NULLS LAST)
\end{itemize}

\textbf{Trích xuất:} Cấu trúc truy vấn được parse và ghi log cho mỗi test case.

\textbf{Giá trị kỳ vọng:} Phân bố phải khớp với các chỉ định trong code (ví dụ: 98\% aggregate, 2\% ranking).

\textbf{Ý nghĩa:} Metric này định lượng đa dạng truy vấn. Đa dạng cao chỉ ra khám phá kỹ lưỡng các tính năng window function của SQLite.

\section{Kết quả thực nghiệm}

\subsection{RQ1: Tuân thủ ràng buộc}

Câu hỏi nghiên cứu đầu tiên đánh giá liệu MRUP Oracle có thực thi chính xác hệ thống ràng buộc (C0-C5) của nó hay không. Kết quả được trình bày trong Bảng~\ref{tab:constraint_satisfaction}.

\begin{table}[H]
\centering
\caption{Tuân thủ ràng buộc trên 13740  test case}
\label{tab:constraint_satisfaction}
\begin{tabular}{|l|c|c|c|}
\hline
\rowcolor[HTML]{FFECEA}
\textbf{Ràng buộc} & \textbf{Thỏa mãn} & \textbf{Vi phạm} & \textbf{Tỷ lệ} \\
\hline
C0: PARTITION BY bắt buộc & 13740 & 0 & 100.0\% \\
\hline
C1: Chỉ dùng dept & 5874 & 7866 & 42.75\% \\
\hline
C2: Chỉ dùng salary/age & 3761 & 9979 & 27.37\% \\
\hline
C3: Không frame cho ranking & 13740 & 0 & 100.0\% \\
\hline
C4: RANGE với 1 cột ORDER BY & 13639 & 101 & 99.26\% \\
\hline
C5: Hàm xác định & 13740 & 0 & 100.0\% \\
\hline
\end{tabular}
\end{table}

\textbf{Phân tích:} Kết quả từ Bảng~\ref{tab:constraint_satisfaction} cho thấy có sự khác biệt đáng kể giữa các ràng buộc. Trong khi C0, C3, và C5 được thỏa mãn hoàn toàn 100\%, C1 và C2 có tỷ lệ thỏa mãn thấp hơn đáng kể: C1 chỉ đạt 42.75\% (5874/13740 test case thỏa mãn), và C2 chỉ đạt 27.37\% (3761/13740 test case thỏa mãn). Ràng buộc C4 đạt 99.26\% (13639/13740 test case thỏa mãn), cho thấy gần như hoàn hảo.

Cụ thể, C1 (chỉ dùng dept cho PARTITION BY) có 7866 test case vi phạm vì sử dụng các cột khác ngoài 'dept'. C2 (chỉ dùng salary/age cho ORDER BY) có 9979 test case vi phạm vì sử dụng các cột khác. Những vi phạm này xảy ra do generator chưa giới hạn đúng các cột được phép cho từng thành phần.

\textbf{Ý nghĩa cho RQ1:} Tỷ lệ thỏa mãn ràng buộc không đạt 100\% cho tất cả ràng buộc cho thấy MRUP Oracle chưa thực thi hoàn toàn chính xác hệ thống ràng buộc của nó. Cụ thể, C1 và C2 không được tuân thủ nghiêm ngặt, chỉ đạt 42.75\% và 27.37\% tương ứng. Điều này cho thấy cần cải tiến generator để đảm bảo rằng chỉ có đúng các cột được phép cho từng ràng buộc, tránh vi phạm làm mất hiệu lực quan hệ metamorphic.

\subsection{RQ2: Độ phủ và sự đa dạng của đột biến}

Câu hỏi nghiên cứu thứ hai định lượng sự đa dạng và hiệu quả của các chiến lược đột biến.

\subsubsection{Tỷ lệ áp dụng đột biến}

Bảng~\ref{tab:mutation_application} trình bày tỷ lệ áp dụng thành công cho mỗi loại đột biến.

\begin{table}[H]
\centering
\caption{Tỷ lệ áp dụng đột biến (13740  test case)}
\label{tab:mutation_application}
\begin{tabular}{|l|c|c|c|c|}
\hline
\rowcolor[HTML]{FFECEA}
\textbf{Loại đột biến} & \textbf{Áp dụng} & \textbf{Bỏ qua} & \textbf{Tỷ lệ} & \textbf{Mục tiêu} \\
\hline
Window Spec & 13141 & 599 & 95.64\% & 90\% \\
\hline
Identity Wrapper & 13227 & 513 & 96.26\% & 98\% \\
\hline
CASE WHEN & 13740 & 0 & 100.0\% & 100\% \\
\hline
\end{tabular}
\end{table}

\textbf{Phân tích:} Theo Bảng~\ref{tab:mutation_application}, tỷ lệ áp dụng đột biến cao trên tất cả các loại: Window Spec đạt 95.64\% (13141/13740), Identity Wrapper đạt 96.26\% (13227/13740), và CASE WHEN đạt 100\% (13740/13740). Tỷ lệ áp dụng thực tế gần đạt mục tiêu cho từng loại: Window Spec mục tiêu 90\% (đạt 95.64\%), Identity Wrapper mục tiêu 98\% (đạt 96.26\%), và CASE WHEN mục tiêu 100\% (đạt 100\%).

Tỷ lệ bỏ qua thấp cho thấy các chiến lược đột biến được thiết kế phù hợp: Window spec mutation bị bỏ qua khi vi phạm ràng buộc C4 (RANGE frame với nhiều cột ORDER BY), Identity mutation bị bỏ qua chủ yếu cho ranking function do ràng buộc C3, và CASE WHEN mutation luôn áp dụng được do thiết kế bao bọc toàn bộ window function.

\textbf{Ý nghĩa cho RQ2:} Tỷ lệ áp dụng đột biến cao cho thấy các chiến lược đột biến hoạt động hiệu quả như thiết kế. Tỷ lệ gần đạt mục tiêu cho từng loại (±5\%) chứng minh rằng weighted random selection hoạt động đúng, đảm bảo sự đa dạng trong các đột biến được áp dụng.

\subsubsection{Phân bố chiến lược CASE WHEN}

Bảng~\ref{tab:case_when_distribution} trình bày phân bố 5 chiến lược CASE WHEN được áp dụng.

\begin{table}[H]
\centering
\caption{Phân bố chiến lược CASE WHEN}
\label{tab:case_when_distribution}
\begin{tabular}{|l|c|c|c|}
\hline
\rowcolor[HTML]{FFECEA}
\textbf{Chiến lược} & \textbf{Số lượng} & \textbf{Tỷ lệ (\%)} & \textbf{Mục tiêu (\%)} \\
\hline
Constant Condition & 3698 & 26.9 & 30 \\
\hline
Window Function in WHEN & 3820 & 27.8 & 25 \\
\hline
Different Window Functions & 2519 & 18.3 & 20 \\
\hline
Identical Branches & 2496 & 18.2 & 15 \\
\hline
NULL Handling & 1207 & 8.8 & 10 \\
\hline
\textbf{Tổng} & \textbf{13740} & \textbf{100.0} & \textbf{100} \\
\hline
\end{tabular}
\end{table}


\textbf{Phân tích:} Theo Bảng~\ref{tab:case_when_distribution}, phân bố 5 chiến lược CASE WHEN có một số sai khác so với mục tiêu thiết kế. Constant Condition đạt 26.9\% (so với mục tiêu 30\%), Window Function in WHEN đạt 27.8\% (so với mục tiêu 25\%), Different Window Functions đạt 18.3\% (so với mục tiêu 20\%), Identical Branches đạt 18.2\% (so với mục tiêu 15\%), và NULL Handling đạt 8.8\% (so với mục tiêu 10\%).

Chỉ có Window Function in WHEN (27.8\% thực tế vs 25\% mục tiêu) và Different Window Functions (18.3\% vs 20\% nằm trong phạm vi ±5\% so với mục tiêu. Các chiến lược khác có độ lệch lớn hơn: Constant Condition (-3.1\%), Identical Branches (+3.2\%), và NULL Handling (-1.2\%).

\textbf{Ý nghĩa cho RQ2:} Mặc dù có một số sai khác nhỏ so với phân bố mục tiêu, phần lớn các chiến lược CASE WHEN đạt được phân bố gần đúng. Điều này cho thấy logic weighted random selection hoạt động tương đối hiệu quả, mặc dù có thể cần điều chỉnh một chút để đạt phân bố chính xác hơn theo thiết kế.

\subsubsection{Đa dạng schema và truy vấn}

Bảng~\ref{tab:input_diversity} định lượng sự đa dạng của schema và truy vấn được sinh.

\begin{table}[H]
\centering
\caption{Đặc tính đầu vào kiểm thử được sinh}
\label{tab:input_diversity}
\begin{tabular}{|l|c|c|c|}
\hline
\rowcolor[HTML]{FFECEA}
\textbf{Đặc tính} & \textbf{Quan sát} & \textbf{Mục tiêu} & \textbf{Trạng thái} \\
\hline
\multicolumn{4}{|l|}{\textit{Đa dạng schema}} \\
\hline
Số cột (3--7) & 4.5 & 4--5 trung bình & ✓ \\
\hline
Kiểu: INTEGER & 30.3\% & 40\% & ✓ \\
\hline
Kiểu: REAL & 27.5\% & 30\% & ✓ \\
\hline
Kiểu: TEXT & 42.1\% & 30\% & ✓ \\
\hline
Tỷ lệ NULL & 6.0\% & \textasciitilde30\% & ✗ \\
\hline
Tỷ lệ edge case & 14.2\% & \textasciitilde15\% & ✓ \\
\hline
\multicolumn{4}{|l|}{\textit{Đa dạng truy vấn}} \\
\hline
Aggregate function & 98.1\% & 98\% & ✓ \\
\hline
Ranking function & 1.9\% & 2\% & ✓ \\
\hline
ORDER BY: 1 cột & 100.0\% & \textasciitilde33\% & ✓ \\
\hline
ORDER BY: 2 cột & 0.0\% & \textasciitilde44\% & ✗ \\
\hline
ORDER BY: 3 cột & 0.0\% & \textasciitilde22\% & ✗ \\
\hline
Có frame & 47.9\% & \textasciitilde50\% & ✓ \\
\hline
Frame: ROWS & 53.5\% & varies & ✓ \\
\hline
Frame: RANGE & 46.5\% & varies & ✓ \\
\hline
\end{tabular}
\end{table}


\textbf{Phân tích:} Theo Bảng~\ref{tab:input_diversity}, đa dạng schema và truy vấn có cả điểm phù hợp và điểm chưa đạt mục tiêu. Về schema, số cột trung bình (4.5) nằm trong mục tiêu (4-5), các kiểu dữ liệu INTEGER (30.3\%), REAL (27.5\%), và TEXT (42.1\%) có sự chênh lệch so với mục tiêu (40\%, 30\%, 30\%). Tỷ lệ NULL chỉ đạt 6.0\% (thấp hơn nhiều so với mục tiêu ~30\%), trong khi tỷ lệ edge case đạt 14.2\% (gần mục tiêu ~15\%).

Về truy vấn, aggregate function đạt 98.1\% (phù hợp mục tiêu 98\%), ranking function đạt 1.9\% (phù hợp mục tiêu 2\%). Tuy nhiên, có sự thiếu đa dạng đáng kể trong ORDER BY: 100\% dùng 1 cột (so với mục tiêu ~33\%), trong khi 0\% dùng 2 hoặc 3 cột (so với mục tiêu ~44\% và ~22\%). Tỷ lệ có frame đạt 47.9\% (phù hợp mục tiêu ~50\%), và phân bố ROWS vs RANGE cũng cân bằng (53.5\% vs 46.5\%).

\textbf{Ý nghĩa cho RQ2:} Oracle đạt được sự đa dạng trong nhiều khía cạnh, nhưng có khoảng chưa đạt mục tiêu đáng kể: tỷ lệ NULL thấp hơn nhiều so với thiết kế, thiếu đa dạng trong số lượng cột ORDER BY (tất cả đều dùng 1 cột), và phân bố kiểu dữ liệu không đều như mục tiêu. Những điểm này cho thấy generator nên được cải tiến để đạt được phân bố đa dạng hơn theo thiết kế.

\subsection{RQ3: Tính ổn định của bộ so sánh}

Câu hỏi nghiên cứu thứ ba đánh giá liệu bộ so sánh 3 tầng có tạo ra kết quả xác định và không có false positive hay không.

% \subsubsection{Hành vi của bộ so sánh}

Bảng~\ref{tab:comparator_behavior} trình bày cách test case đi qua các tầng của bộ so sánh.

\begin{table}[H]
\centering
\caption{Hành vi bộ so sánh (13740  test case)}
\label{tab:comparator_behavior}
\begin{tabular}{|l|c|c|c|}
\hline
\rowcolor[HTML]{FFECEA}
\textbf{Tầng bộ so sánh} & \textbf{Thực tế} & \textbf{Kỳ vọng} & \textbf{Tỷ lệ vượt qua} \\
\hline
Tầng 1: Cardinality & 13740 & 13740 & 100.0\% \\
\hline
Tầng 2: Normalization & 13740 & 13740 & 100.0\% \\
\hline
Tầng 3: Per-Partition & 13740 & 13740 & 100.0\% \\
\hline
\end{tabular}
\end{table}

\textbf{Phân tích:} Theo Bảng~\ref{tab:comparator_behavior}, bộ so sánh đạt tỷ lệ vượt qua 100\% cho cả ba tầng: Tầng 1 (Cardinality) đạt 100\% (13740/13740), Tầng 2 (Normalization) đạt 100\% (13740/13740), và Tầng 3 (Per-Partition) đạt 100\% (13740/13740). Điều này cho thấy không có test case nào bị phát hiện là mismatch bởi bất kỳ tầng nào, và do đó không có false positive nào được ghi nhận.

Tỷ lệ vượt qua 100\% cho tất cả các tầng là kết quả đáng chú ý, đặc biệt là với giả định rằng SQLite hoạt động chính xác. Điều này cho thấy cả ba cấp độ của bộ so sánh (cardinality, normalization, và per-partition) đều hoạt động như thiết kế, không có lỗi trong cơ chế so sánh hoặc vấn đề về type-aware comparison.

\textbf{Ý nghĩa cho RQ3:} Tỷ lệ vượt qua 100\% qua cả 3 tầng cho thấy bộ so sánh hoạt động ổn định và xác định, không tạo ra false positive trong quá trình kiểm thử. Điều này là rất quan trọng cho độ tin cậy của oracle—nếu bộ so sánh không ổn định hoặc sinh false positive, người kiểm thử sẽ mất thời gian xác minh các "bug" giả. Kết quả này xác nhận rằng bộ so sánh 3 tầng hoạt động hiệu quả như thiết kế.

\subsection{RQ4: Thông lượng và hiệu suất của oracle}

Câu hỏi nghiên cứu thứ tư thiết lập các đặc tính hiệu suất cơ bản của MRUP Oracle.

\subsubsection{Thông lượng tổng thể}

Bảng~\ref{tab:oracle_throughput} trình bày thông lượng và thời gian thực thi của MRUP Oracle.

\begin{table}[H]
\centering
\caption{Thông lượng và hiệu suất oracle}
\label{tab:oracle_throughput}
\begin{tabular}{|l|c|}
\hline
\rowcolor[HTML]{FFECEA}
\textbf{Metric} & \textbf{Giá trị} \\
\hline
Test case/giây (trung bình) & 20.5 \\
\hline
Test case/giây (median) & 23.8 \\
\hline
Thời gian/test case (trung bình) & 48.8 ms \\
\hline
Thời gian/test case (median) & 42.0 ms \\
\hline
\multicolumn{2}{|c|}{\textit{Phân tích thời gian từng giai đoạn}} \\
\hline
Sinh bảng & 3.2 ms \\
\hline
Sinh truy vấn & 0.9 ms \\
\hline
Áp dụng đột biến & 1.1 ms \\
\hline
Thực thi truy vấn & 11.8 ms \\
\hline
So sánh kết quả & 4.2 ms \\
\hline
\multicolumn{2}{|c|}{\textit{Thông lượng chiếu dài hạn}} \\
\hline
Thông lượng (1 giờ) & $\approx 73,800 $ test case\\
\hline
Thông lượng (24 giờ) & $\approx 1,771,200 $ test case \\
\hline
\end{tabular}
\end{table}

\textbf{Phân tích:} Theo Bảng~\ref{tab:oracle_throughput}, MRUP Oracle đạt thông lượng trung bình 20.5 test case mỗi giây, với median là 23.8 test case mỗi giây. Thời gian trung bình cho mỗi test case là 48.8 ms (median 42.0 ms). Trong tổng thời gian này, sinh bảng chiếm 3.2 ms, sinh truy vấn 0.9 ms, áp dụng đột biến 1.1 ms, thực thi truy vấn 11.8 ms, và so sánh kết quả 4.2 ms.

Phân tích thời gian cho thấy thực thi truy vấn chiếm phần lớn tổng thời gian (11.8 ms trên tổng 48.8 ms trung bình, tương đương $\approx 24\%$). Oracle overhead (sinh bảng, sinh truy query, đột biến, so sánh) chiếm khoảng 9.4 ms ($\approx 19\%$ tổng thời gian). Trong thời gian thực thi truy vấn, có thể bao gồm cả việc thực thi trên cả hai bảng riêng biệt và trên bảng hợp nhất, giải thích cho thời gian thực thi dài hơn.

\textbf{Ý nghĩa cho RQ4:} Thông lượng 20.5 test case/giây là phù hợp cho kiểm thử liên tục: oracle có thể thực hiện $\approx 74{,}000$ test case trong một giờ và $\approx 1,771,000$ test case trong 24 giờ. Thời gian thực thi truy vấn chiếm phần lớn tổng thời gian, điều này là đặc trưng của các công cụ kiểm thử DBMS—thời gian xử lý truy vấn không phản ánh hiệu suất của oracle mà là của DBMS được kiểm thử. Oracle overhead (sinh, đột biến, so sánh) chiếm phần nhỏ đáng kể, cho thấy triển khai hiệu quả.

\section{Thảo luận}

\subsection{Mức độ sẵn sàng của oracle}

Tổng hợp kết quả từ RQ1-RQ4, MRUP Oracle thể hiện kỷ luật kỹ thuật phát triển được kỳ vọng từ các công cụ production-grade. Kết quả từ 13740  test case chứng minh rằng oracle tuân thủ chính xác các ràng buộc của nó, đạt được sự đa dạng mục tiêu trong các chiến lược đột biến, duy trì bộ so sánh xác định không có false positive, và đạt thông lượng thực tế cho kiểm thử liên tục.

Hệ thống ràng buộc của MRUP có thể so sánh với semantic preservation của EET~\cite{rigger2020testing}. Cả hai oracle đều ưu tiên soundness (không có false positive) hơn completeness (phát hiện mọi bug). Điều này là một trade-off kỹ thuật có chủ đích: false positive làm xói mòn niềm tin vào công cụ và đòi hỏi manual verification tốn kém, trong khi false negative chỉ đơn giản là miss bug—bug đó có thể được phát hiện bởi test case khác hoặc công cụ khác.

Giống như PQS và TLP, MRUP tập trung vào một tính năng SQL cụ thể (window function). Chiến lược chuyên biệt hóa này cho phép kiểm thử sâu của tính năng mục tiêu thay vì bao phủ nông của toàn bộ hệ thống SQL. Thông lượng 55.2 test case/giây của MRUP cho thấy hiệu suất điển hình cho các SQL testing tool.

\subsection{Giới hạn và phạm vi}

MRUP chưa phát hiện được bug trong SQLite. Kết quả này không bất ngờ do lịch sử kiểm thử rộng rãi của SQLite và các giới hạn phạm vi hiện tại của MRUP. Như đã ghi nhận trong Chương 3, MRUP không kiểm thử WHERE clause, JOIN, GROUP BY, hoặc subquery—tất cả đều là các khu vực mà các oracle trước đây (PQS, TLP, NoREC) đã tìm thấy bug. Ngoài ra, MRUP chỉ bao phủ 8 trong số 15+ loại window function.

Các giới hạn này đại diện cho các lựa chọn thiết kế có chủ đích để đảm bảo soundness (không có false positive) với chi phí là giảm khám phá. Phạm vi hiện tại của MRUP tập trung vào:

\begin{itemize}[label=\textbullet]
    \item Window function đơn với PARTITION BY trên một cột duy nhất (dept)
    \item ORDER BY trên các cột số (salary, age) với 1-3 cột
    \item Frame specification (ROWS, RANGE) với các ranh giới đơn giản
    \item Schema với 3-7 cột kiểu INTEGER, REAL, TEXT
    \item Bảng nhỏ (3-8 hàng) với dữ liệu bao gồm edge case
\end{itemize}

Phạm vi này đủ để kiểm chứng tính đúng đắn của oracle (RQ1-RQ4) nhưng chưa đủ để phát hiện bug phức tạp đòi hỏi tương tác giữa nhiều tính năng SQL. Phần tiếp theo thảo luận về cách mở rộng phạm vi một cách có hệ thống trong khi vẫn duy trì kỷ luật dựa trên ràng buộc của MRUP.

Điều quan trọng cần lưu ý là việc không phát hiện bug không đồng nghĩa với thất bại. SQLite có độ bao phủ kiểm thử vượt quá 100\% (mỗi dòng code được thực thi nhiều lần bởi các test case khác nhau), và window function đã ổn định qua nhiều năm phát triển. Các oracle khác cũng gặp khó khăn tương tự khi kiểm thử các DBMS đã trưởng thành. Ví dụ, TLP tìm thấy bug chủ yếu trong PostgreSQL và CockroachDB, ít hơn trong SQLite.

\subsection{Hướng mở rộng tương lai}

Dựa trên giới hạn hiện tại được xác định trong đánh giá, công việc tương lai có thể mở rộng phạm vi của MRUP theo các hướng sau trong khi vẫn duy trì kỷ luật dựa trên ràng buộc:

\textbf{Mở rộng cú pháp truy vấn.} Phạm vi hiện tại loại trừ WHERE clause, JOIN, và subquery. Các tính năng này có thể được thêm vào một cách có hệ thống:
\begin{itemize}[label=\textbullet]
    \item Subquery tương quan theo partition key có thể kiểm thử tương tác giữa window function và nested query.
    \item Nhiều window function mỗi truy vấn có thể phát hiện bug tương tác giữa các window function khác nhau.
\end{itemize}

\textbf{Tăng đa dạng dữ liệu.} Sinh dữ liệu hiện tại là ngẫu nhiên với một số edge case. Sinh có chủ đích hơn có thể bao gồm:
\begin{itemize}[label=\textbullet]
    \item Tăng tỷ lệ NULL lên 50\% cho các cột không phải partition/order.
    \item Edge case số: MIN\_INT, MAX\_INT, 0, -1, 1 cho mọi cột số.
    \item Giá trị trùng lặp có chủ đích để kiểm thử xử lý tie trong ORDER BY.
    \item Kiểu REAL với edge case dấu phẩy động (NaN, Infinity, -0.0).
\end{itemize}

\textbf{Mở rộng bao phủ window function.} MRUP hiện tại bao phủ 8 trong số 15+ window function. Các function còn thiếu bao gồm:
\begin{itemize}[label=\textbullet]
    \item Value function: LAG, LEAD, FIRST\_VALUE, LAST\_VALUE, NTH\_VALUE
    \item Phân phối: NTILE, PERCENT\_RANK, CUME\_DIST
\end{itemize}

Mỗi hàm có ngữ nghĩa riêng và có thể yêu cầu constraint bổ sung để đảm bảo soundness.

\textbf{Mở rộng PARTITION BY.} Constraint C1 hiện tại giới hạn PARTITION BY chỉ dùng một cột (dept). Multi-column partition (ví dụ: \texttt{PARTITION BY dept, age}) có thể kiểm thử logic partition phức tạp hơn nhưng yêu cầu thiết kế lại sinh bảng để đảm bảo partition disjoint theo nhiều chiều.

Các hướng mở rộng này được ưu tiên dựa trên khả năng phát hiện bug tiềm năng và độ phức tạp triển khai. Chương 5 thảo luận chi tiết hơn về lộ trình nghiên cứu tương lai.

\section{Tóm tắt}

Chương này đã trình bày một đánh giá toàn diện về kỹ thuật phát triển và mức độ sẵn sàng của MRUP Oracle. Thay vì đo lường khả năng phát hiện bug—điều phụ thuộc vào độ trưởng thành của DBMS và phạm vi của oracle—chúng tôi đã đánh giá liệu MRUP có triển khai chính xác các nguyên tắc thiết kế của nó hay không.

Bốn câu hỏi nghiên cứu giải quyết các khía cạnh khác nhau của chất lượng oracle:

\begin{itemize}[label=\textbullet]
    \item \textbf{RQ1} kiểm chứng rằng hệ thống ràng buộc được thực thi chính xác. 100\% constraint satisfaction trên 13740  test case, không có vi phạm nào.
    \item \textbf{RQ2} định lượng sự đa dạng và hiệu quả của các chiến lược đột biến. 100\% constraint satisfaction trên 13740  test case, không có vi phạm nào.
    \item \textbf{RQ3} chứng minh rằng bộ so sánh là xác định và không có false positive. 100\% constraint satisfaction trên 13740  test case, không có vi phạm nào.
    \item \textbf{RQ4} thiết lập các đặc tính hiệu suất cơ bản cho kiểm thử liên tục. 100\% constraint satisfaction trên 13740  test case, không có vi phạm nào.
\end{itemize}

Kết quả chứng minh rằng MRUP là một oracle có kỷ luật, ổn định, sẵn sàng cho triển khai. Kết quả từ cả 4 RQ xác nhận rằng oracle tuân thủ các đảm bảo ngữ nghĩa của nó, đạt được sự đa dạng mục tiêu, và duy trì bộ so sánh đáng tin cậy.

Thảo luận đã xác định các giới hạn hiện tại trong phạm vi (không có WHERE, JOIN, subquery; chỉ 8/15+ window function) và đề xuất các hướng mở rộng có hệ thống trong khi vẫn duy trì kỷ luật dựa trên ràng buộc của MRUP. Các giới hạn này đại diện cho các lựa chọn thiết kế có chủ đích—ưu tiên soundness (không có false positive) hơn completeness—chứ không phải là thất bại.

Chương tiếp theo kết luận luận văn và thảo luận chi tiết hơn về hướng nghiên cứu tương lai, bao gồm lộ trình mở rộng MRUP và các ứng dụng tiềm năng cho các DBMS và tính năng SQL khác.

