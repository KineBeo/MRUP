\clearpage
\phantomsection

\setcounter{chapter}{1}
\chapter[{CÔNG TRÌNH LIÊN QUAN}]{Công trình liên quan}

\noindent Chương này trình bày tổng quan về các kỹ thuật kiểm thử tự động DBMS hiện đại, phân tích điểm mạnh và hạn chế của từng phương pháp, từ đó xác định khoảng trống nghiên cứu về kiểm thử window functions và động lực phát triển MRUP Oracle.

\section{Các kỹ thuật kiểm thử DBMS hiện đại}

\subsection{Pivoted Query Synthesis (PQS)}

\noindent PQS \cite{Rigger2020} là phương pháp metamorphic testing được Manuel Rigger và Zhendong Su phát triển, công bố tại OSDI 2020. Ý tưởng cốt lõi của PQS là giải quyết vấn đề oracle cho một hàng đơn lẻ được chọn ngẫu nhiên, gọi là pivot row, bằng cách tổng hợp truy vấn mà tập kết quả bắt buộc phải chứa hàng này. Nếu DBMS không truy xuất được pivot row, một lỗi logic đã được phát hiện.

\subsubsection{Cách tiếp cận}

\noindent PQS hoạt động theo quy trình bảy bước: tạo cơ sở dữ liệu ngẫu nhiên, chọn pivot row từ các bảng, tạo biểu thức ngẫu nhiên dưới dạng AST, đánh giá các biểu thức dựa trên pivot row và điều chỉnh chúng để trả về TRUE (quá trình rectification), sử dụng các biểu thức đã chỉnh sửa trong mệnh đề WHERE hoặc JOIN, thực thi truy vấn bằng DBMS, và cuối cùng xác minh pivot row có trong tập kết quả.

% TODO: Insert figure here
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{figures/fuzzing/PQS-overview.png}
    % \fbox{\parbox{0.9\textwidth}{\centering\vspace{2cm}[Placeholder: PQS Overview Diagram]\\\vspace{0.5cm}7-step workflow: Database generation → Pivot row selection → Expression generation → Rectification → Query synthesis → Execution → Verification\vspace{2cm}}}
    \caption{Tổng quan cách tiếp cận của PQS}
    \label{fig:pqs_overview}
\end{figure}
\vspace{5em}
{Một ví dụ điển hình là lỗi nghiêm trọng trong SQLite thể hiện như sau:}

\begin{center}
\begin{lstlisting}[caption={Illustrative example, based on a critical SQLite bug}, label={lst:pqs_example}]
CREATE TABLE t0 ( c0 );
CREATE INDEX i0 ON t0 (1) WHERE c0 NOT NULL;
INSERT INTO t0 ( c0 ) VALUES (0), (1), (NULL);
SELECT c0 FROM t0 WHERE c0 IS NOT 1; -- actual: {0} [BUG] | expected: {0, NULL} 
\end{lstlisting}
\end{center}

Truy vấn chứa mệnh đề \texttt{WHERE c0 IS NOT 1}, và vì \texttt{NULL IS NOT 1} đánh giá là TRUE, hàng NULL được kỳ vọng trong kết quả. Tuy nhiên, do lỗi tối ưu hóa (SQLite sử dụng partial index dựa trên giả định \texttt{c0 IS NOT 1} ngụ ý \texttt{c0 NOT NULL}), hàng NULL bị bỏ qua, dẫn đến kết quả chỉ có \{\} thay vì \{0, NULL\}. Cụ thể, với pivot row \texttt{c0=NULL}, vì \texttt{NULL IS NOT 1} đánh giá là TRUE, hàng NULL được kỳ vọng trong kết quả nhưng bị bỏ qua vì SQLite cho rằng \texttt{c0 IS NOT 1} ngụ ý \texttt{c0 NOT NULL}.

\subsubsection{Kết quả và đánh giá}

\noindent PQS đã chứng minh hiệu quả cao với 121 lỗi duy nhất được phát hiện, trong đó 96 lỗi đã được sửa hoặc xác minh. Tổng cộng 61 lỗi là lỗi logic. PQS cung cấp exact oracle vì dựa trên đánh giá biểu thức của chính nó thông qua trình thông dịch AST để xác định kết quả kỳ vọng. Nỗ lực triển khai thấp khi so sánh với kích thước DBMS vì chỉ cần xử lý một pivot row thay vì toàn bộ cơ sở dữ liệu.

\begin{table}[H]
    \centering
    \small
    \begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{DBMS} & \textbf{Fixed} & \textbf{Verified} & \textbf{Intended} & \textbf{Duplicate} \\ \hline
SQLite & 64 & 0 & 4 & 2 \\ \hline
MySQL & 17 & 7 & 2 & 4 \\ \hline
PostgreSQL & 5 & 3 & 7 & 6 \\ \hline
\textbf{Tổng} & \textbf{86} & \textbf{10} & \textbf{13} & \textbf{12} \\ \hline
\end{tabular}
    \caption{Tình trạng các lỗi được phát hiện bởi PQS}
    \label{tab:pqs_bugs_status}
\end{table}

\begin{table}[H]
    \centering
    \small
    \begin{tabular}{|l|c|c|c|}
\hline
\textbf{DBMS} & \textbf{Logic} & \textbf{Error} & \textbf{SEGFAULT} \\ \hline
SQLite & 46 & 16 & 2 \\ \hline
MySQL & 14 & 9 & 1 \\ \hline
PostgreSQL & 1 & 7 & 0 \\ \hline
\textbf{Tổng} & \textbf{61} & \textbf{32} & \textbf{3} \\ \hline
\end{tabular}
    \caption{Phân loại lỗi thực sự được phát hiện bởi PQS (96 lỗi)}
    \label{tab:pqs_bugs_classification}
\end{table}

Tuy nhiên, PQS có những hạn chế đáng kể. Nỗ lực triển khai cao do phải triển khai lại thủ công các toán tử và hàm được DBMS hỗ trợ. PQS chỉ xác thực một phần kết quả dựa trên pivot row và không thể phát hiện các hàng trùng lặp bị bỏ sót hoặc được thêm sai. Do đó, PQS không thể xác thực tính đúng đắn của aggregate functions, window functions, kích thước tập kết quả, hoặc thứ tự kết quả. Phương pháp này cũng không phù hợp để kiểm tra mệnh đề OFFSET và LIMIT vì chúng có thể loại trừ pivot row khỏi tập kết quả.

\subsection{Non-Optimizing Reference Engine Construction (NoREC)}

\noindent NoREC \cite{Rigger2020NoREC} là kỹ thuật tổng quát và hiệu quả về chi phí để tìm kiếm lỗi tối ưu hóa (optimization bugs) trong DBMS. Lỗi tối ưu hóa là loại lỗi logic khiến trình tối ưu hóa truy vấn tính toán tập kết quả không chính xác.

\subsubsection{Cách tiếp cận}

\noindent Ý tưởng cấp cao của NoREC là so sánh kết quả của phiên bản DBMS có tối ưu hóa với phiên bản không thực hiện tối ưu hóa. Vì việc tắt tối ưu hóa khó khăn, ý tưởng cốt lõi là viết lại truy vấn được tối ưu hóa (optimized query) thành truy vấn mà DBMS không thể tối ưu hóa hiệu quả (unoptimized query). Cụ thể, truy vấn dạng \texttt{SELECT * FROM t0 WHERE }$\varphi$
được biến đổi thành
\texttt{SELECT (}$\varphi$\texttt{ IS TRUE) FROM t0}
. Việc di chuyển mệnh đề WHERE đến sau SELECT khiến DBMS phải truy xuất mọi bản ghi, vô hiệu hóa hầu hết các cơ chế tối ưu hóa.

% TODO: Insert figure here
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{figures/fuzzing/NoREC-overview.png}
    \caption{Tổng quan cách tiếp cận của NoREC}
    \label{fig:norec_overview}
\end{figure}

Ví dụ minh họa dựa trên lỗi trong SQLite thể hiện như sau:

\begin{center}
\begin{lstlisting}[caption={NoREC example based on SQLite bug}, label={lst:norec_example}]
CREATE TABLE t0 ( c0 UNIQUE );
INSERT INTO t0 VALUES ( -1) ;
SELECT * FROM t0 WHERE t0 . c0 GLOB ' -* '; -- : {} [BUG]
SELECT t0 . c0 GLOB ' -* ' FROM t0 ; -- { TRUE } [Correct] 
\end{lstlisting}
\end{center}

Truy vấn tối ưu hóa \texttt{SELECT * FROM t0 WHERE t0.c0 GLOB '-*';} trả về \{\} (tập rỗng) do tối ưu hóa LIKE sai, trong khi truy vấn không tối ưu hóa \texttt{SELECT t0.c0 GLOB '-*' FROM t0;} đánh giá predicate trên mọi bản ghi và trả về \{TRUE\}. Sự không nhất quán này (0 hàng vs 1 TRUE) phát hiện ra lỗi.

\subsubsection{Kết quả và đánh giá}

\noindent NoREC đã tìm thấy 159 lỗi chưa từng được biết đến, trong đó 141 lỗi đã được sửa. Phương pháp này phát hiện hiệu quả các lỗi tối ưu hóa, yêu cầu nỗ lực triển khai thấp và rất tổng quát vì dựa trên quy trình dịch thuật đơn giản. NoREC đã tìm thấy hơn 100 lỗi bổ sung trong SQLite mặc dù SQLite đã được PQS kiểm tra kỹ lưỡng.

\begin{table}[H]
    \centering
    \small
    \begin{tabular}{|l|c|c|c|}
\hline
\textbf{DBMS} & \textbf{Logic (Optimization)} & \textbf{Error} & \textbf{Crash/Assertion} \\ \hline
SQLite & 39 & 30 & 41 \\ \hline
MariaDB & 5 & 0 & 1 \\ \hline
PostgreSQL & 0 & 4 & 3 \\ \hline
CockroachDB & 7 & 24 & 4 \\ \hline
\textbf{Tổng} & \textbf{51} & \textbf{58} & \textbf{74} \\ \hline
\end{tabular}
    \caption{Phân loại lỗi được phát hiện bởi NoREC (159 lỗi)}
    \label{tab:norec_bugs}
\end{table}

Hạn chế của NoREC là tính tổng quát bị giới hạn, chủ yếu chỉ áp dụng để kiểm tra mệnh đề WHERE. Phương pháp này không áp dụng trực tiếp cho DISTINCT, aggregate functions, hoặc window functions. NoREC không thể phát hiện lỗi nếu tối ưu hóa làm mất đi lỗi/ngoại lệ được mong đợi (do short-circuit evaluation không nhất quán), hoặc nếu DBMS trả về tập kết quả sai nhưng có đúng số lượng bản ghi.

\subsection{Ternary Logic Partitioning (TLP)}

\noindent TLP \cite{Rigger2020TLP} là sự cụ thể hóa của ý tưởng Query Partitioning, một kỹ thuật tổng quát để tìm lỗi logic. Ý tưởng cốt lõi là chia truy vấn gốc ($Q$) thành nhiều truy vấn phân vùng ($Q'_0...Q'_{n-1}$), mỗi truy vấn tính toán một phần kết quả. Các phần kết quả được kết hợp bằng toán tử ($RS(Q')$). Nếu kết quả kết hợp khác với kết quả truy vấn gốc ($RS(Q) \ne RS(Q')$), một lỗi logic được phát hiện.

\subsubsection{Cách tiếp cận}

\noindent TLP tận dụng logic ba giá trị của SQL (Ternary Logic): một predicate $\phi$ luôn đánh giá thành TRUE, FALSE, hoặc NULL. TLP phân vùng truy vấn thành ba biến thể predicate ternary dựa trên $\phi$ (TRUE), NOT $\phi$ (FALSE), và $\phi$ IS NULL (NULL). Các truy vấn phân vùng này được kết hợp bằng toán tử $\diamond$ (thường là UNION ALL hoặc UNION).

% TODO: Insert figure here
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{figures/fuzzing/TLP-overview.png}
    % \fbox{\parbox{0.9\textwidth}{\centering\vspace{2cm}[Placeholder: TLP Overview Diagram]\\\vspace{0.5cm}Query Q → Partition into Q'\_p, Q'\_¬p, Q'\_p IS NULL\\Combine: RS(Q') = RS(Q'\_p) ∪ RS(Q'\_¬p) ∪ RS(Q'\_p IS NULL)\\Compare: RS(Q) vs RS(Q')\vspace{2cm}}}
    \caption{Tổng quan cách tiếp cận của TLP}
    \label{fig:tlp_overview}
\end{figure}

Ví dụ minh họa dựa trên lỗi MySQL thể hiện như sau:

\begin{center}
\begin{lstlisting}[caption={A logic bug in MySQL caused a predicate 0=-0 to incorrectly evaluate to FALSE}, label={lst:tlp_example}]
CREATE TABLE t0 ( c0 INT );
CREATE TABLE t1 ( c0 DOUBLE );
INSERT INTO t0 VALUES (0) ;
INSERT INTO t1 VALUES ( ' -0 ');
SELECT * FROM t0 , t1 WHERE t0 . c0 = t1 . c0 ; -- {} [BUG]
SELECT * FROM t0 , t1 ; -- {0 , -0} [CORRECT]
SELECT * FROM t0 , t1 WHERE t0 . c0 = t1 . c0
UNION ALL SELECT * FROM t0 , t1 WHERE NOT ( t0 . c0 = t1 . c0 )
UNION ALL SELECT * FROM t0 , t1 WHERE ( t0 . c0 = t1 . c0 ) IS NULL ; -- {} [BUG]
\end{lstlisting}
\end{center}

Truy vấn gốc \texttt{SELECT * FROM t0, t1;} (cross product) trả về \{0, -0\} (đúng). Predicate được chọn là \texttt{t0.c0 = t1.c0}. Truy vấn phân vùng kết hợp ba truy vấn con bằng UNION ALL. MySQL xử lý sai truy vấn con đầu tiên (vì \texttt{0 = -0} đánh giá thành FALSE), dẫn đến kết quả kết hợp là \{\} (tập rỗng). Do $RS(O) \ne RS(P)$, lỗi logic được phát hiện.

\subsubsection{Kết quả và đánh giá}

\noindent TLP là phương pháp tổng quát, hiệu quả và đã tìm thấy nhiều lỗi trong các tính năng phức tạp mà PQS và NoREC không xử lý được. TLP có tính tổng quát cao, có thể kiểm tra phạm vi tính năng rộng hơn đáng kể, bao gồm mệnh đề WHERE, GROUP BY, HAVING, aggregate functions và truy vấn DISTINCT. Yêu cầu nỗ lực triển khai thấp.

TLP đã tìm thấy 175 lỗi chưa từng được biết đến, trong đó 125 lỗi đã được sửa. Tổng cộng 77 lỗi là lỗi logic.

\begin{table}[H]
    \centering
    \small
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
\textbf{DBMS} & \textbf{WHERE} & \textbf{Aggregate} & \textbf{GROUP BY} & \textbf{HAVING} & \textbf{DISTINCT} & \textbf{Error} & \textbf{Crash} \\ \hline
SQLite & 0 & 3 & 0 & 0 & 1 & 0 & 0 \\ \hline
CockroachDB & 3 & 3 & 0 & 1 & 0 & 22 & 2 \\ \hline
TiDB & 29 & 0 & 1 & 0 & 0 & 27 & 4 \\ \hline
MySQL & 7 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
DuckDB & 21 & 4 & 1 & 2 & 1 & 13 & 19 \\ \hline
\textbf{Tổng Logic} & \textbf{60} & \textbf{10} & \textbf{2} & \textbf{3} & \textbf{2} & & \\ \hline
\end{tabular}
    \caption{Số lượng lỗi logic được phát hiện bởi từng TLP Oracle}
    \label{tab:tlp_bugs}
\end{table}

Hạn chế của TLP là không thể thiết lập ground truth. Tương tự NoREC, TLP là phương pháp metamorphic testing, không thể đảm bảo tính đúng đắn tuyệt đối. Nếu truy vấn gốc và truy vấn phân vùng đều tính toán sai nhưng trả về kết quả giống nhau, lỗi sẽ bị bỏ sót. TLP không áp dụng cho transactions, window functions, sequences, và các hàm không xác định (non-deterministic functions). Phương pháp này cũng có hạn chế đối với các truy vấn có kết quả không rõ ràng như subqueries.

\subsection{Equivalent Expression Transformation (EET)}

\noindent EET là phương pháp mới và tổng quát để phát hiện lỗi logic trong DBMS, sử dụng thao tác cấp độ biểu thức (expression-level manipulation) thay vì thao tác cấp độ truy vấn (query-level manipulation). Ý tưởng cốt lõi là thao tác các biểu thức của truy vấn theo cách bảo toàn ngữ nghĩa (semantic-preserving), do đó bảo toàn ngữ nghĩa của toàn bộ truy vấn và độc lập với các mẫu truy vấn.

\subsubsection{Cách tiếp cận}

\noindent EET xác thực DBMS bằng cách kiểm tra xem các truy vấn đã biến đổi có trả về cùng kết quả với các truy vấn gốc hay không. Các loại biến đổi chính bao gồm Determined Boolean Expressions (áp dụng các luật tương đương logic để biến đổi biểu thức boolean, ví dụ: $p \equiv \text{TRUE AND } p$) và Redundant Branch Structures (sử dụng cấu trúc rẽ nhánh kiểu SQL như biểu thức CASE WHEN để biến đổi các biểu thức non-boolean, đảm bảo kết quả tương đương với biểu thức gốc).

% TODO: Insert figure here
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{figures/fuzzing/EET-overview.png}
    % \fbox{\parbox{0.9\textwidth}{\centering\vspace{2cm}[Placeholder: EET Overview Diagram]\\\vspace{0.5cm}SQL Query → Parse to AST → Expression Transformation\\→ Transformed SQL Query → Compare Results\vspace{2cm}}}
    \caption{Tổng quan cách tiếp cận của EET}
    \label{fig:eet_overview}
\end{figure}

Ví dụ minh họa dựa trên lỗi logic trong DBMS thể hiện như sau:

\begin{center}
\begin{lstlisting}[caption={EET example: Original vs Transformed query}, label={lst:eet_example}]
--- Statements for database generation
CREATE TABLE t0 (c0 TEXT);
CREATE TABLE t1 (c0 TEXT);
CREATE TABLE t2 (c0 INT4, c1 INT4, c2 TEXT,
                c3 TEXT, c4 TEXT, c5 TEXT);
INSERT INTO t0 values ('');
INSERT INTO t1 values ('');
INSERT INTO t2 values (1, 2, 'a', 'a', 'a', 'a'),
                      (0, 1, '', '', 'a', 'L');
--- Original query, result set: 0 [CORRECT]
SELECT t2.c0 FROM t2
WHERE (t2.c1 >= t2.c0) <> (t2.c5 = (
    SELECT t2.c4 AS c_0
    FROM (t1 AS ref_0 INNER JOIN t0 AS ref_1
        ON (ref_0.c0 = ref_1.c0))
    WHERE t2.c3 = t2.c2
    ORDER BY c_0 DESC LIMIT 1));
--- Transformed query, result set: empty [BUG]
SELECT t2.c0 FROM t2
WHERE (t2.c1 >= t2.c0) <> (t2.c5 = (
SELECT t2.c4 AS c_0
FROM (t1 AS ref_0 INNER JOIN t0 AS ref_1
ON (ref_0.c0 = ref_1.c0))
WHERE (CASE WHEN (((ref_0.c0 LIKE 'z~%')
AND (NOT (ref_0.c0 LIKE 'z~%')))
AND ((ref_0.c0 LIKE 'z~%') IS NOT NULL))
THEN t2.c3 ELSE t2.c3 END) =
(CASE WHEN (((ref_1.c0 NOT LIKE '_%%')
      AND (NOT (ref_1.c0 NOT LIKE '_%%')))
      AND ((ref_1.c0 NOT LIKE '_%%') IS NOT NULL))
 THEN t2.c4 ELSE t2.c2 END)
ORDER BY c_0 DESC LIMIT 1));
\end{lstlisting}
\end{center}
Ví dụ minh họa dựa trên lỗi logic 20 năm tuổi trong PostgreSQL: Truy vấn gốc chứa các biểu thức như \texttt{t2.c2} và \texttt{t2.c3}. EET biến đổi các biểu thức này thành hai biểu thức CASE WHEN tương đương về mặt ngữ nghĩa (Redundant Branch Structures). Mặc dù hai truy vấn về mặt ngữ nghĩa giống nhau, truy vấn gốc trả về \{0\} (1 hàng), trong khi truy vấn đã biến đổi trả về tập rỗng (empty set), cho thấy lỗi logic. Sự khác biệt xảy ra vì các biểu thức biến đổi khiến PostgreSQL sử dụng logic thực thi khác (cơ chế hash-join bị lỗi).

EET biến đổi các biểu thức tương đương về mặt ngữ nghĩa (Redundant Branch Structures). Mặc dù hai truy vấn về mặt ngữ nghĩa giống nhau, truy vấn gốc trả về \{0\} (1 hàng), trong khi truy vấn đã biến đổi trả về tập rỗng (empty set), cho thấy lỗi logic. Sự khác biệt xảy ra vì các biểu thức biến đổi khiến DBMS sử dụng logic thực thi khác.

\subsubsection{Kết quả và đánh giá}

\noindent EET đã chứng minh tính tổng quát và hiệu quả trong việc tìm kiếm lỗi logic, đặc biệt trong các truy vấn phức tạp. Tính tổng quát vượt trội của EET cho phép áp dụng cho các truy vấn tùy ý (arbitrary queries) mà không giới hạn mẫu truy vấn. EET có khả năng hỗ trợ các tính năng SQL phức tạp như subquery tương quan (correlated subqueries), phép JOIN, window functions, và DML (những tính năng mà các phương pháp khác gặp khó khăn). Về độ tin cậy (Soundness), EET được đảm bảo bảo toàn ngữ nghĩa, không tạo ra false positives trong việc phát hiện lỗi logic.

EET đã tìm thấy 66 lỗi duy nhất trong 5 DBMS được kiểm tra. Tổng cộng 35 lỗi là lỗi logic.

\begin{table}[H]
    \centering
    \small
    \begin{tabular}{|l|c|c|c|}
\hline
\textbf{DBMS} & \textbf{Reported} & \textbf{Confirmed} & \textbf{Fixed} \\ \hline
MySQL & 16 & 16 & 2 \\ \hline
PostgreSQL & 9 & 9 & 8 \\ \hline
SQLite & 10 & 10 & 10 \\ \hline
ClickHouse & 21 & 20 & 15 \\ \hline
TiDB & 10 & 10 & 2 \\ \hline
\textbf{Tổng} & \textbf{66} & \textbf{65} & \textbf{37} \\ \hline
\end{tabular}
    \caption{Tình trạng các lỗi được phát hiện bởi EET}
    \label{tab:eet_bugs_status}
\end{table}

\begin{table}[H]
    \centering
    \small
    \begin{tabular}{|l|c|c|c|}
\hline
\textbf{DBMS} & \textbf{Logic} & \textbf{Crash} & \textbf{Error} \\ \hline
MySQL & 10 & 6 & 0 \\ \hline
PostgreSQL & 3 & 3 & 3 \\ \hline
SQLite & 9 & 0 & 1 \\ \hline
ClickHouse & 11 & 3 & 7 \\ \hline
TiDB & 2 & 7 & 1 \\ \hline
\textbf{Tổng} & \textbf{35} & \textbf{19} & \textbf{12} \\ \hline
\end{tabular}
    \caption{Phân loại lỗi được phát hiện bởi EET (66 lỗi)}
    \label{tab:eet_bugs_classification}
\end{table}

Hạn chế của EET là khả năng bỏ sót lỗi nếu cả truy vấn gốc và truy vấn đã biến đổi đều tạo ra cùng kết quả không chính xác. Tốc độ xử lý thấp hơn vì EET hỗ trợ các truy vấn phức tạp, DBMS mất nhiều thời gian hơn để thực thi chúng, dẫn đến throughput thấp hơn so với các phương pháp hiện có.

\section{Phân tích khoảng trống nghiên cứu và động lực phát triển MRUP Oracle}

\noindent Qua khảo sát các công trình nghiên cứu về kiểm thử DBMS, chúng tôi nhận thấy việc kiểm tra các tính năng SQL phức tạp như Window Functions là một thách thức lớn đối với các oracle truyền thống. PQS gặp khó khăn trong việc hỗ trợ các tính năng SQL nâng cao liên quan đến tính toán phức tạp do yêu cầu kết quả của các truy vấn được tạo phải được dự đoán bằng trình thông dịch được triển khai thủ công. PQS không thể tìm thấy lỗi trong các window functions. NoREC không áp dụng trực tiếp cho các truy vấn tính toán kết quả trên nhiều bản ghi, bao gồm cả window functions. TLP không áp dụng cho window functions.

EET đã giải quyết được khoảng trống nghiên cứu này bằng cách hỗ trợ các truy vấn có chứa window functions. Trong số 35 lỗi logic mà EET tìm thấy, có 4 truy vấn kích hoạt lỗi sử dụng window functions (ví dụ: DENSE\_RANK, FIRST\_VALUE). Trước EET, việc thiếu tính tổng quát trong các phương pháp tiếp cận hiện có (chủ yếu dựa trên thao tác cấp độ truy vấn) đã giới hạn khả năng của chúng trong việc kiểm tra các truy vấn phức tạp, bao gồm cả những truy vấn sử dụng window functions.

\begin{table}[H]
    \centering
    \small
    \begin{tabular}{|l|c|c|c|}
\hline
\textbf{Oracle} & \textbf{WHERE clause} & \textbf{Window Functions} & \textbf{Frame Specs} \\ \hline
PQS & \checkmark & $\times$ & $\times$ \\ \hline
NoREC & \checkmark & $\times$ & $\times$ \\ \hline
TLP & \checkmark & $\times$ & $\times$ \\ \hline
EET & \checkmark & $\triangle$ & $\times$ \\ \hline
\textbf{MRUP (đề xuất)} & $\triangle$ & \checkmark & \checkmark \\ \hline
\end{tabular}
    \caption{So sánh khả năng hỗ trợ Window Functions của các oracle (\checkmark = đầy đủ, $\triangle$ = hạn chế, $\times$ = không hỗ trợ)}
    \label{tab:oracle_comparison}
\end{table}

\noindent Từ phần phân tích chi tiết cho thấy các khoảng trống về kiểm thử window function như sau:

\textbf{Thiếu oracle chuyên biệt cho window functions.} PQS, TLP, NoREC chủ yếu tập trung vào WHERE clause, JOIN, GROUP BY. Không có oracle nào khai thác tính chất partition locality của window functions. Không có oracle nào kiểm thử chuyên sâu về frame specifications.

\textbf{Thiếu kiểm thử về ORDER BY phức tạp.} Window functions phụ thuộc nhiều vào ORDER BY (ranking, frame boundaries). Các oracle hiện tại không tập trung vào ordering semantics. Không kiểm thử NULL handling trong ORDER BY (NULLS FIRST/LAST).

\textbf{Thiếu kiểm thử về frame specifications.} Các khía cạnh chưa được kiểm thử đầy đủ bao gồm:
\begin{itemize}[label=\textbullet]
    \item ROWS vs RANGE frames
    \item Frame boundaries (PRECEDING, FOLLOWING, UNBOUNDED)
    \item Frame exclusions (EXCLUDE CURRENT ROW, EXCLUDE GROUP)
\end{itemize}

\textbf{Thiếu kiểm thử về tương tác giữa nhiều window functions.} Các oracle hiện tại chủ yếu kiểm thử một window function đơn lẻ. Không kiểm thử tương tác giữa nhiều window functions trong cùng một query. Không kiểm thử window functions trong subqueries, CTEs.

Chương tiếp theo sẽ trình bày chi tiết về thiết kế và triển khai MRUP Oracle.

